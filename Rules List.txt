Rules for AI-Assisted Web Projects
1. Core Philosophy & Environment üèõÔ∏è
The Golden Rule: The project must be fully functional when index.html is opened directly in a browser from the local file system (using the file:/// protocol). Server-dependent features like Service Workers must degrade gracefully, meaning they should not run or cause errors in this environment.
No Servers or Build Tools: The solution must not require a local web server or any command-line tools for building, compiling, or package management (e.g., npm, Vite).
Client-Side Only: All code must run entirely in the browser. There is no backend.
Robustness First: The application must be resilient, providing fallbacks for potentially failing external resources (like CDNs) and handling runtime errors gracefully.

2. Project Structure & Assets üìÅ
JavaScript Modularity: The application logic must be split into multiple, single-responsibility files. The established pattern is:
Data Files: Located in src/js/data/ (e.g., theme-data.js, locations.js).
Data-Specific Notes: A root /live/ directory for large, biller-specific data files (e.g., BGE.js).
Core Logic: Located in src/js/core/ and src/js/features/.
UI Rendering: Located in src/js/ui/.
Initialization: The main entry point is src/js/main/app-main.js.
CSS Architecture: Stylesheets must be split for maintainability:
theme.css: Contains CSS variables for the design system (colors, spacing, etc.).
Component CSS: Separate files for each major component or view (e.g., base.css, header.css, biller-card.css, modal.css).
Asset Loading: Any new .js or .css file must be added to the appropriate array in src/js/core/loader.js in the correct, dependency-aware order to ensure it is loaded by the browser.

3. Code & Functionality üíª
Core Technologies: The project must only use HTML, CSS, and vanilla JavaScript (ES6+). No frameworks (React, Vue) or external component libraries (Bootstrap) are permitted.
JavaScript Communication: Since ES Modules (import/export) are forbidden, communication between .js files is achieved via the global scope (e.g., const UI = {}, const Features = {}) and a meticulous script loading order managed by loader.js.
Defensive Programming:
Null Checks: Always check if a DOM element exists before attempting to access its properties or methods.
Error Boundaries: Wrap critical initialization blocks (like the main init() function) in a try...catch block to prevent a single failure from crashing the application.
Refactoring Integrity: When a function or object is moved from one file to another, all other files that reference that code must be updated to point to its new location.
Data Contract Consistency: Any function that consumes data from another file must be written to match the exact data structure of the source. If a data source's structure is changed, the consuming function must be updated in the same step.

4. UI, UX & Accessibility ‚ú®
User Feedback: All interactive elements must provide clear visual feedback for hover, active, and focus states.
Tooltip Mandate: Any interactive UI element whose function is not immediately obvious from its design or label must have a data-tooltip attribute providing a concise explanation on hover and focus.
Modal Behavior: All modal dialogs (.modal-overlay) must be dismissible by clicking on the overlay area outside the main content box. They must also feature a smooth transition animation for opening and closing.
Accessibility: Use semantic HTML and ARIA attributes where necessary to ensure the application is accessible.
Data Consistency: All biller-specific notes (e.g., BGE.js) must follow a standardized structure. The standard tabs must be defined in this exact order: alerts (danger), fees (primary), contact (info), channels (info), and system (secondary). Custom tabs may follow.

5. AI Collaboration & Workflow ü§ñ
The Planning Rule: For any request involving multiple files or significant feature changes, I must first devise a detailed plan that includes a diagnosis, a proposed solution, and a complete list of all new and modified files.
Approval is Mandatory: I will not generate any code until you have explicitly reviewed and approved the plan.
DOM Caching and Injection Order: The operational sequence must be: (1) Inject HTML templates into the DOM, (2) then cache the newly-added elements by ID, and (3) then attach event listeners to them.
Output Formatting: My generated code will be clean and will not include any citation markers or other extraneous formatting.
File Naming: New filenames should be concise and descriptive (e.g., loader.js instead of asset-and-dependency-loader.js).


//////////////////////////////////////////////


Project Rules
1. Core Philosophy & Environment
The project must be fully functional when index.html is opened directly from the local file system (file:/// protocol). Server-dependent features must degrade gracefully.
No local web server or command-line build tools (npm, Vite, etc.) are required.
All code must be client-side only.
The application must be robust, with fallbacks for failing external resources and graceful error handling.

2. Project Structure & Modularity
A highly modular, multi-file structure is mandatory.
JavaScript: Logic must be split into single-responsibility files (Data, Core Logic, UI Rendering, Features, Initialization).
CSS: Stylesheets must be split (theme.css for variables, and separate files like base.css, header.css, biller-card.css for structure and layout).

3. Code & Functionality
Core Technologies: HTML, CSS, and vanilla JavaScript (ES6+) only. No frameworks or external component libraries.
JavaScript Communication: No import/export. Communication is achieved via the global scope and a meticulous script loading order in index.html.
Defensive Programming: Always check for null DOM elements before use and wrap critical initialization blocks in try...catch.

4. AI Collaboration & Workflow
For any significant feature change, the AI must first devise a detailed plan listing all new and modified files.
The AI must not generate any code until the user has explicitly reviewed and approved the plan.

5. UI & Data Consistency
All biller-specific notes (e.g., BGE.js, PAC.js) must follow a standardized structure to ensure a consistent user experience.
The standard tabs must be defined in this exact order: alerts (danger), fees (primary), contact (info), channels (info), system (secondary).

6. Refactoring Integrity (New)
When a function or object is moved from a source file to a new destination file as part of refactoring, all other files that call or reference that code must be updated to use its new location.

7. DOM Caching and Injection Order (New)
Scripts must not attempt to cache DOM elements that are injected at runtime before the injection occurs. The correct operational sequence is: (1) Inject HTML templates into the DOM, (2) then cache the newly-added elements by ID, and (3) then attach event listeners to them.

8. Data Contract Consistency (New)
Any function that consumes data from another file (e.g., a feature module consuming a data module) must be written to match the exact data structure of the source file. If a data source's structure is changed, the consuming function must be updated in the same step.

9. Asset Loading (New)
Whenever a new .js or .css file is created, a corresponding <script> or <link> tag must be added to index.html in the correct, dependency-aware order to ensure it is loaded by the browser.

10. AI Output Formatting (New)
The AI must never include citation markers (e.g., ``) in any generated file or code block. All generated content must be clean of these markers.
